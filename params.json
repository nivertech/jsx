{"google":"","body":"# jsx (v1.3) #\r\n\r\nan erlang application for consuming, producing and manipulating [json][json]. inspired by [yajl][yajl]\r\n\r\ncopyright 2011, 2012 alisdair sullivan\r\n\r\njsx is released under the terms of the [MIT][MIT] license\r\n\r\njsx may be built using either [sinan][sinan] or [rebar][rebar]\r\n\r\n[![Build Status](https://secure.travis-ci.org/talentdeficit/jsx.png?branch=master)](http://travis-ci.org/talentdeficit/jsx)\r\n\r\n\r\n## index ##\r\n\r\n* [quickstart](#quickstart)\r\n* [description](#description)\r\n  - [json <-> erlang mapping](#json---erlang-mapping)\r\n  - [incomplete input](#incomplete-input)\r\n* [data types](#data-types)\r\n  - [`json_term()`](#json_term)\r\n  - [`json_text()`](#json_text)\r\n  - [`token()`](#token)\r\n  - [`event()`](#event)\r\n  - [`option()`](#option)\r\n* [exports](#exports)\r\n  - [`encoder/3`, `decoder/3` & `parser/3`](#encoder3-decoder3--parser3)\r\n  - [`decode/1,2`](#decode12)\r\n  - [`encode/1,2`](#encode12)\r\n  - [`format/1,2`](#format12)\r\n  - [`minify/1`](#minify1)\r\n  - [`prettify/1`](#prettify1)\r\n  - [`is_json/1,2`](#is_json12)\r\n  - [`is_term/1,2`](#is_term12)\r\n* [callback exports](#callback_exports)\r\n  - [`Module:init/1`](#moduleinit1)\r\n  - [`Module:handle_event/2`](#modulehandle_event2)\r\n* [acknowledgements](#acknowledgements)\r\n\r\n\r\n## quickstart ##\r\n\r\n#### to build the library and run tests ####\r\n\r\n```bash\r\ntanga:jsx alisdair$ sinan build\r\ntanga:jsx alisdair$ sinan -r tests eunit\r\n```\r\nor\r\n```bash\r\ntanga:jsx alisdair$ rebar compile\r\ntanga:jsx alisdair$ rebar eunit\r\n```\r\n\r\n#### to convert a utf8 binary containing a json string into an erlang term ####\r\n\r\n```erlang\r\n1> jsx:decode(<<\"{\\\"library\\\": \\\"jsx\\\", \\\"awesome\\\": true}\">>).\r\n[{<<\"library\">>,<<\"jsx\">>},{<<\"awesome\">>,true}]\r\n2> jsx:decode(<<\"[\\\"a\\\",\\\"list\\\",\\\"of\\\",\\\"words\\\"]\">>).\r\n[<<\"a\">>, <<\"list\">>, <<\"of\">>, <<\"words\">>]\r\n```\r\n\r\n#### to convert an erlang term into a utf8 binary containing a json string ####\r\n\r\n```erlang\r\n1> jsx:encode([{<<\"library\">>,<<\"jsx\">>},{<<\"awesome\">>,true}]).\r\n<<\"{\\\"library\\\": \\\"jsx\\\", \\\"awesome\\\": true}\">>\r\n2> jsx:encode([<<\"a\">>, <<\"list\">>, <<\"of\">>, <<\"words\">>]).\r\n<<\"[\\\"a\\\",\\\"list\\\",\\\"of\\\",\\\"words\\\"]\">>\r\n```\r\n\r\n#### to check if a binary or a term is valid json ####\r\n\r\n```erlang\r\n1> jsx:is_json(<<\"[\\\"this is json\\\"]\">>).\r\ntrue\r\n2> jsx:is_json(\"[\\\"this is not\\\"]\").\r\nfalse\r\n3> jsx:is_term([<<\"this is a term\">>]).\r\ntrue\r\n4> jsx:is_term([\"this is not\"]).\r\nfalse\r\n```\r\n\r\n#### to minify some json ####\r\n\r\n```erlang\r\n1> jsx:minify(<<\"{\r\n  \\\"a list\\\": [\r\n    1,\r\n    2,\r\n    3\r\n  ]\r\n}\">>).\r\n<<\"{\\\"a list\\\":[1,2,3]}\">>\r\n```\r\n\r\n#### to prettify some json ####\r\n\r\n```erlang\r\n1> jsx:prettify(<<\"{\\\"a list\\\":[1,2,3]}\">>).\r\n<<\"{\r\n  \\\"a list\\\": [\r\n    1,\r\n    2,\r\n    3\r\n  ]\r\n}\">>\r\n```\r\n\r\n\r\n## description ##\r\n\r\n\r\njsx is an erlang application for consuming, producing and manipulating [json][json]\r\n\r\njson has a [spec][rfc4627] but common usage differs subtly. it's common usage jsx attempts to address, with guidance from the spec\r\n\r\nall json produced and consumed by jsx should be `utf8` encoded text or a reasonable approximation thereof. ascii works too, but anything beyond that i'm not going to make any promises\r\n\r\nthe [spec][rfc4627] thinks json values must be wrapped in a json array or object but everyone else disagrees so jsx allows naked json values by default. if you're a curmudgeon who's offended by this deviation, you can just check that all values returned by jsx functions are lists, alright?\r\n\r\nhere is a table of how various json values map to erlang:\r\n\r\n### json &lt;-> erlang mapping ###\r\n\r\n**json**                        | **erlang**\r\n--------------------------------|--------------------------------\r\n`number`                        | `integer()` and `float()`\r\n`string`                        | `binary()`\r\n`true`, `false` and `null`      | `true`, `false` and `null`\r\n`array`                         | `[]` and `[JSON]`\r\n`object`                        | `[{}]` and `[{binary() OR atom(), JSON}]`\r\n\r\n*   numbers\r\n\r\n    javascript and thus json represent all numeric values with floats. as this is woefully insufficient for many uses, **jsx**, just like erlang, supports bigints. whenever possible, this library will interpret json numbers that look like integers as integers. other numbers will be converted to erlang's floating point type, which is nearly but not quite iee754. negative zero is not representable in erlang (zero is unsigned in erlang and `0` is equivalent to `-0`) and will be interpreted as regular zero. numbers not representable are beyond the concern of this implementation, and will result in parsing errors\r\n\r\n    when converting from erlang to json, numbers are represented with their shortest representation that will round trip without loss of precision. this means that some floats may be superficially dissimilar (although functionally equivalent). for example, `1.0000000000000001` will be represented by `1.0`\r\n\r\n*   strings\r\n\r\n    the json [spec][rfc4627] is frustratingly vague on the exact details of json strings. json must be unicode, but no encoding is specified. javascript explicitly allows strings containing codepoints explicitly disallowed by unicode. json allows implementations to set limits on the content of strings. other implementations attempt to resolve this in various ways. this implementation, in default operation, only accepts strings that meet the constraints set out in the json spec (strings are sequences of unicode codepoints deliminated by `\"` (`u+0022`) that may not contain control codes unless properly escaped with `\\` (`u+005c`)) and that are encoded in `utf8`\r\n\r\n    the utf8 restriction means improperly paired surrogates are explicitly disallowed. `u+d800` to `u+dfff` are allowed, but only when they form valid surrogate pairs. surrogates encountered otherwise result in errors\r\n\r\n    json string escapes of the form `\\uXXXX` will be converted to their equivalent codepoints during parsing. this means control characters and other codepoints disallowed by the json spec may be encountered in resulting strings, but codepoints disallowed by the unicode spec will not be. in the interest of pragmatism there is an [option](#option) for looser parsing\r\n\r\n    all erlang strings are represented by *valid* `utf8` encoded binaries. the encoder will check strings for conformance. noncharacters (like `u+ffff`) are allowed in erlang utf8 encoded binaries, but not in strings passed to the encoder (although, again, see [options](#option))\r\n\r\n    this implementation performs no normalization on strings beyond that detailed here. be careful when comparing strings as equivalent strings may have different `utf8` encodings\r\n\r\n*   true, false and null\r\n\r\n    the json primitives `true`, `false` and `null` are represented by the erlang atoms `true`, `false` and `null`. surprise\r\n\r\n*   arrays\r\n\r\n    json arrays are represented with erlang lists of json values as described in this section\r\n\r\n*   objects\r\n\r\n    json objects are represented by erlang proplists. the empty object has the special representation `[{}]` to differentiate it from the empty list. ambiguities like `[true, false]` prevent the use of the shorthand form of property lists using atoms as properties so all properties must be tuples. all keys must be encoded as in `string` or as atoms (which will be escaped and converted to binaries for presentation to handlers). values should be valid json values\r\n\r\n\r\n### incomplete input ###\r\n\r\njsx handles incomplete json texts. if a partial json text is parsed, rather than returning a term from your callback handler, jsx returns `{incomplete, F}` where `F` is a function with an identical API to the anonymous fun returned from `decoder/3`, `encoder/3` or `parser/3`. it retains the internal state of the parser at the point where input was exhausted. this allows you to parse as you stream json over a socket or file descriptor, or to parse large json texts without needing to keep them entirely in memory\r\n\r\nhowever, it is important to recognize that jsx is greedy by default. jsx will consider the parsing complete if input is exhausted and the json text is not unambiguously incomplete. this is mostly relevant when parsing bare numbers like `<<\"1234\">>`. this could be a complete json integer or just the beginning of a json integer that is being parsed incrementally. jsx will treat it as a whole integer. the [option](#options) `explicit_end` can be used to modify this behaviour\r\n\r\n\r\n## data types ##\r\n\r\n#### `json_term()` ####\r\n\r\n```erlang\r\njson_term() = [json_term()]\r\n    | [{binary() | atom(), json_term()}]\r\n    | true\r\n    | false\r\n    | null\r\n    | integer()\r\n    | float()\r\n    | binary()\r\n```\r\n\r\nthe erlang representation of json. binaries should be `utf8` encoded, or close at least\r\n\r\n#### `json_text()` ####\r\n\r\n```erlang\r\njson_text() = binary()\r\n```\r\n\r\na utf8 encoded binary containing a json string\r\n\r\n#### `token()` ####\r\n\r\n```erlang\r\ntoken() = start_object\r\n    | end_object\r\n    | start_array\r\n    | end_array\r\n    | {key, binary()}\r\n    | {string, binary()}\r\n    | binary()\r\n    | {number, integer() | float()}\r\n    | {integer, integer()}\r\n    | {float, float()}\r\n    | integer()\r\n    | float()\r\n    | {literal, true}\r\n    | {literal, false}\r\n    | {literal, null}\r\n    | true\r\n    | false\r\n    | null\r\n    | end_json\r\n```\r\n\r\nthe internal representation used during syntactic analysis\r\n\r\n#### `event()` ####\r\n\r\n```erlang\r\nevent() = start_object\r\n    | end_object\r\n    | start_array\r\n    | end_array\r\n    | {key, binary()}\r\n    | {string, binary()}\r\n    | {integer, integer()}\r\n    | {float, float()}\r\n    | {literal, true}\r\n    | {literal, false}\r\n    | {literal, null}\r\n    | end_json\r\n```\r\n\r\nthe internal representation used during semantic analysis\r\n\r\n#### `option()` ####\r\n\r\n```erlang\r\noption() = replaced_bad_utf8\r\n    | escaped_forward_slashes\r\n    | single_quoted_strings\r\n    | unescaped_jsonp\r\n    | comments\r\n    | escaped_strings\r\n    | dirty_strings\r\n    | ignored_bad_escapes\r\n    | relax\r\n    | explicit_end\r\n```\r\n\r\njsx functions all take a common set of options. not all flags have meaning in all contexts, but they are always valid options. functions may have additional options beyond these. see [individual function documentation](#exports) for details\r\n\r\n- `replaced_bad_utf8`\r\n\r\n    json text input and json strings SHOULD be utf8 encoded binaries, appropriately escaped as per the json spec. attempts are made to replace invalid codepoints with `u+FFFD` as per the unicode spec when this option is present. this applies both to malformed unicode and disallowed codepoints\r\n\r\n- `escaped_forward_slashes`\r\n\r\n    json strings are escaped according to the json spec. this means forward slashes (solidus) are optionally escaped. this option is only relevant for encoding; you may want to use this if you are embedding json directly into a html or xml document\r\n\r\n- `single_quoted_strings`\r\n\r\n    some parsers allow double quotes (`u+0022`) to be replaced by single quotes (`u+0027`) to delimit keys and strings. this option allows json containing single quotes as structural characters to be parsed without errors. note that the parser expects strings to be terminated by the same quote type that opened it and that single quotes must, obviously, be escaped within strings delimited by single quotes\r\n\r\n    double quotes must ALWAYS be escaped, regardless of what kind of quotes delimit the string they are found in\r\n\r\n    the parser will never emit json with keys or strings delimited by single quotes\r\n\r\n- `unescaped_jsonp`\r\n\r\n    javascript interpreters treat the codepoints `u+2028` and `u+2029` as significant whitespace. json strings that contain either of these codepoints will be parsed incorrectly by some javascript interpreters. by default, these codepoints are escaped (to `\\u2028` and `\\u2029`, respectively) to retain compatibility. this option simply removes that escaping\r\n\r\n- `comments`\r\n\r\n    json has no official comments but some parsers allow c style comments. anywhere whitespace is allowed this flag allows comments (both `// ...` and `/* ... */` style)\r\n\r\n- `escaped_strings`\r\n\r\n    by default, both the encoder and decoder return strings as utf8 binaries appropriate for use in erlang. escape sequences that were present in decoded terms are converted into the appropriate codepoint while encoded terms are unaltered. this flag escapes strings as if for output in json, removing control codes and problematic codepoints and replacing them with the appropriate escapes\r\n\r\n- `dirty_strings`\r\n\r\n    json escaping is lossy; it mutates the json string and repeated application can result in unwanted behaviour. if your strings are already escaped (or you'd like to force invalid strings into \"json\") use this flag to bypass escaping\r\n\r\n- `ignored_bad_escapes`\r\n\r\n    during decoding, ignore unrecognized escape sequences and leave them as is in the stream. note that combining this option with `escaped_strings` will result in the escape character itself being escaped\r\n\r\n- `explicit_end`\r\n\r\n    this option treats all exhausted inputs as incomplete. the parser will not attempt to return a final state until the function is called with the value `end_stream`\r\n\r\n- `relax`\r\n\r\n    relax is a synonym for `[replaced_bad_utf8, single_quoted_strings, comments, ignored_bad_escapes]` for when you don't care how janky and awful your json input is, you just want the parser to do the best it can\r\n\r\n\r\n## exports ##\r\n\r\n\r\n#### `encoder/3`, `decoder/3` & `parser/3` ####\r\n\r\n```erlang\r\ndecoder(Module, Args, Opts) -> Fun((JSONText) -> any())\r\nencoder(Module, Args, Opts) -> Fun((JSONTerm) -> any())\r\nparser(Module, Args, Opts) -> Fun((Tokens) -> any())\r\n\r\n  Module = atom()\r\n  Args = any()\r\n  Opts = [option()]\r\n  JSONText = json_text()\r\n  JSONTerm = json_term()\r\n  Tokens = token() | [token()]\r\n```\r\n\r\njsx is a json compiler with interleaved tokenizing, syntactic analysis and semantic analysis stages. included are two tokenizers; one that handles json texts (`decoder/3`) and one that handles erlang terms (`encoder/3`). there is also an entry point to the syntactic analysis stage for use with user-defined tokenizers (`parser/3`)\r\n\r\nall three functions return an anonymous function that takes the appropriate type of input and returns the result of performing semantic analysis, the tuple `{incomplete, F}` where `F` is a new anonymous function (see [incomplete input](#incomplete_input)) or a `badarg` error exception if syntactic analysis fails\r\n\r\n`Module` is the name of the callback module\r\n\r\n`Args` is any term that will be passed to `Module:init/1` prior to syntactic analysis to produce an initial state\r\n\r\n`Opts` are detailed [here](#option) \r\n\r\ncheck out [callback module documentation](#callback_exports) for details of the callback module interface\r\n\r\n#### `decode/1,2` ####\r\n\r\n```erlang\r\ndecode(JSON) -> Term\r\ndecode(JSON, Opts) -> Term\r\n\r\n  JSON = json_text()\r\n  Term = json_term()\r\n  Opts = [option() | labels | {labels, Label} | {post_decode, F}]\r\n    Label = binary | atom | existing_atom\r\n    F = fun((any()) -> any())\r\n```\r\n\r\n`decode` parses a json text (a `utf8` encoded binary) and produces an erlang term\r\n\r\nthe option `labels` controls how keys are converted from json to erlang terms. `binary` does no conversion beyond normal escaping. `atom` converts keys to erlang atoms and results in a badarg error if the keys fall outside the range of erlang atoms. `existing_atom` is identical to `atom` except it will not add new atoms to the atom table\r\n\r\n`{post_decode, F}` is a user defined function of arity 1 that is called on each output value (objects, arrays, strings, numbers and literals). it may return any value to be substituted in the returned term. for example:\r\n\r\n```erlang\r\n1> F = fun(V) when is_list(V) -> V; (V) -> false end.\r\n2> jsx:decode(<<\"{\\\"a list\\\": [true, \\\"a string\\\", 1]}\">>, [{post_decode, F}]).\r\n[{<<\"a list\">>, [false, false, false]}]\r\n```\r\n\r\ndeclaring more than one post-decoder will result in a `badarg` error exception\r\n\r\nraises a `badarg` error exception if input is not valid json\r\n\r\n\r\n#### `encode/1,2` ####\r\n\r\n```erlang\r\nencode(Term) -> JSON\r\nencode(Term, Opts) -> JSON\r\n\r\n  Term = json_term()\r\n  JSON = json_text()\r\n  Opts = [option() | {pre_encode, F} | space | {space, N} | indent | {indent, N}]\r\n    F = fun((any()) -> any())\r\n    N = pos_integer()\r\n```\r\n\r\n`encode` parses a json text (a `utf8` encoded binary) and produces an erlang term\r\n\r\nthe option `{space, N}` inserts `N` spaces after every comma and colon in your json output. `space` is an alias for `{space, 1}`. the default is `{space, 0}`\r\n\r\nthe option `{indent, N}` inserts a newline and `N` spaces for each level of indentation in your json output. note that this overrides spaces inserted after a comma. `indent` is an alias for `{indent, 1}`. the default is `{indent, 0}`\r\n\r\n`{pre_encode, F}` is a user defined function of arity 1 that is called on each input value. it may return any valid json value to be substituted in the returned json. for example:\r\n\r\n```erlang\r\n1> F = fun(V) when is_list(V) -> V; (V) -> false end.\r\n2> jsx:encode([{<<\"a list\">>, [true, <<\"a string\">>, 1]}], [{pre_encode, F}]).\r\n<<\"{\\\"a list\\\": [false, false, false]}\">>\r\n```\r\n\r\ndeclaring more than one pre-encoder will result in a `badarg` error exception\r\n\r\nraises a `badarg` error exception if input is not a valid [erlang representation of json](#json---erlang-mapping)\r\n\r\n\r\n#### `format/1,2` ####\r\n\r\n```erlang\r\nformat(JSON) -> JSON\r\nformat(JSON, Opts) -> JSON\r\n\r\n  JSON = json_text()\r\n  Opts = [option() | space | {space, N} | indent | {indent, N}]\r\n    N = pos_integer()\r\n```\r\n\r\n`format` parses a json text (a `utf8` encoded binary) and produces a new json text according to the format rules specified by `Opts`\r\n\r\nthe option `{space, N}` inserts `N` spaces after every comma and colon in your json output. `space` is an alias for `{space, 1}`. the default is `{space, 0}`\r\n\r\nthe option `{indent, N}` inserts a newline and `N` spaces for each level of indentation in your json output. note that this overrides spaces inserted after a comma. `indent` is an alias for `{indent, 1}`. the default is `{indent, 0}`\r\n\r\nraises a `badarg` error exception if input is not valid json\r\n\r\n\r\n#### `minify/1` ####\r\n\r\n```erlang\r\nminify(JSON) -> JSON\r\n\r\n  JSON = json_text()\r\n```\r\n\r\n`minify` parses a json text (a `utf8` encoded binary) and produces a new json text stripped of whitespace\r\n\r\nraises a `badarg` error exception if input is not valid json\r\n\r\n\r\n#### `prettify/1` ####\r\n\r\n```erlang\r\nprettify(JSON) -> JSON\r\n\r\n  JSON = json_text()\r\n```\r\n\r\n`prettify` parses a json text (a `utf8` encoded binary) and produces a new json text equivalent to `format(JSON, [{space, 1}, {indent, 2}])`\r\n\r\nraises a `badarg` error exception if input is not valid json\r\n\r\n\r\n#### `is_json/1,2` ####\r\n\r\n```erlang\r\nis_json(MaybeJSON) -> true | false\r\nis_json(MaybeJSON, Opts) -> true | false\r\n\r\n  MaybeJSON = any()\r\n  Opts = options()\r\n```\r\n\r\nreturns true if input is a valid json text, false if not\r\n\r\nwhat exactly constitutes valid json may be [altered](#option)\r\n\r\n\r\n#### `is_term/1,2` ####\r\n\r\n```erlang\r\nis_term(MaybeJSON) -> true | false\r\nis_term(MaybeJSON, Opts) -> true | false\r\n\r\n  MaybeJSON = any()\r\n  Opts = options()\r\n```\r\n\r\nreturns true if input is a valid erlang representation of json, false if not\r\n\r\nwhat exactly constitutes valid json may be [altered](#option)\r\n\r\n## callback exports ##\r\n\r\nthe following functions should be exported from a jsx callback module\r\n\r\n#### `Module:init/1` ####\r\n\r\n```erlang\r\nModule:init(Args) -> InitialState\r\n\r\n  Args = any()\r\n  InitialState = any()\r\n```\r\n\r\nwhenever any of `encoder/3`, `decoder/3` or `parser/3` are called, this function is called with the `Args` argument provided in the calling function to obtain `InitialState`\r\n\r\n#### `Module:handle_event/2` ####\r\n\r\n```erlang\r\nModule:handle_event(Event, State) -> NewState\r\n\r\n  Event = [event()]\r\n  State = any()\r\n  NewState = any()\r\n```\r\n\r\nsemantic analysis is performed by repeatedly calling `handle_event/2` with a stream of events emitted by the tokenizer and the current state. the new state returned is used as the input to the next call to `handle_event/2`. the following events must be handled:\r\n\r\n-   `start_object`\r\n\r\n    the start of a json object\r\n\r\n-   `end_object`\r\n\r\n    the end of a json object\r\n\r\n-   `start_array`\r\n\r\n    the start of a json array\r\n\r\n-   `end_array`\r\n\r\n    the end of a json array\r\n\r\n-   `{key, binary()}`\r\n\r\n    a key in a json object. this is guaranteed to follow either `start_object` or a json value. it will usually be a `utf8` encoded binary. see the [options](#option) for possible exceptions\r\n\r\n-   `{string, binary()}`\r\n\r\n    a json string. it will usually be a `utf8` encoded binary. see the [options](#option) for possible exceptions\r\n\r\n-   `{integer, integer()}`\r\n\r\n    an erlang integer (bignum)\r\n\r\n-   `{float, float()}`\r\n\r\n    an erlang float\r\n\r\n-   `{literal, true}`\r\n\r\n    the atom `true`\r\n\r\n-   `{literal, false}`\r\n\r\n    the atom `false`\r\n\r\n-   `{literal, null}`\r\n\r\n    the atom `null`\r\n\r\n-   `end_json`\r\n\r\n    this event is emitted when syntactic analysis is completed. you should do any cleanup and return the result of your semantic analysis\r\n\r\n\r\n## acknowledgements ##\r\n\r\njsx wouldn't be what it is without the contributions of [paul davis](https://github.com/davisp), [lloyd hilaiel](https://github.com/lloyd), [john engelhart](https://github.com/johnezang), [bob ippolito](https://github.com/etrepum), [fernando benavides](https://github.com/elbrujohalcon), [alex kropivny](https://github.com/amtal), [steve strong](https://github.com/srstrong), [michael truog](https://github.com/okeuday), [dmitry kolesnikov](https://github.com/fogfish) and [emptytea](https://github.com/emptytea)\r\n\r\n[json]: http://json.org\r\n[yajl]: http://lloyd.github.com/yajl\r\n[MIT]: http://www.opensource.org/licenses/mit-license.html\r\n[rebar]: https://github.com/basho/rebar\r\n[sinan]: https://github.com/erlware/sinan\r\n[meck]: https://github.com/eproxus/meck\r\n[rfc4627]: http://tools.ietf.org/html/rfc4627\r\n","tagline":"an erlang application for consuming, producing and manipulating json. inspired by yajl","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"jsx"}